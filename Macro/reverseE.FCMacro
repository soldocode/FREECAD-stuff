########################################################################
#                                                                      #
#  Riccardo Soldini - riccardo.soldini@gmail.com                       #
#                                                                      #
#  reversE.py - 2017                                                   #
#                                                                      #
#  Modulo per la decostruzione di parti di carpenteria da file STEP    #
#  ricostruzione in parti in formato makEasy                           #
#  e generazione del processo di costruzione  (workflow)               #
#                                                                      #
########################################################################


import pprint
import math

def is_planes_parallels(face1,face2):
    result=False
    n1=face1.normalAt(0,0)
    n2=face2.normalAt(0,0)
    accuracy=8

    ax1=round(abs(math.degrees(n1.x)),accuracy)
    #print 'ax1:',ax1
    ay1=round(abs(math.degrees(n1.y)),accuracy)
    az1=round(abs(math.degrees(n1.z)),accuracy)
    
    ax2=round(abs(math.degrees(n2.x)),accuracy)
    #print 'ax2:',ax2
    ay2=round(abs(math.degrees(n2.y)),accuracy)
    az2=round(abs(math.degrees(n2.z)),accuracy)
                  
    if (((ax1==ax2) and (ay1==ay2)) and (az1==az2)):
        result=True
    return result


def deconstruct_object(obj):

 faces=obj.Shape.Faces

 c_surf={}
 p_surf={}
 b_part=[]
 plane_areas={}	
 faces_tree={"Plane":{},
             "Cylinder":{},
             "Cone":{}}

 fnum=len(faces)
 print 'Number of faces:',fnum

 ### create color tree
 actcolor=sel.Object.ViewObject.DiffuseColor[0]
 dcol=[]
 for i in range (0,fnum):
     dcol.append(actcolor)

 ### Build faces's tree
 for i in range(0,len(faces)):
    str_face=faces[i].Surface.__str__()
    if str_face=="<Cylinder object>":
        #print ("Cylinder",i," - center:",faces[i].Surface.Center)
        c_surf[i]=faces[i]
        faces_tree['Cylinder'][i]=faces[i]
    elif str_face=="<Plane object>":
        #print ("Plane",i," - number of edges:",len(faces[i].Edges))
        p_surf[i]=faces[i]	
        faces_tree['Plane'][i]=faces[i]
        area=faces[i].Area
        if area in plane_areas:
            plane_areas[area].append(i)
        else:
            plane_areas[area]=[i]
    elif str_face=="<Cone object>":
        #print ("Cone",i," - center",faces[i].Surface.Center)
        faces_tree['Cone'][i]=faces[i]

 #pp.pprint(faces_tree) 

 ### Find greater faces
 print 'Top plane areas:'
 topareas=sorted(plane_areas,reverse=True)[:2]
 #for ta in topareas:
    #print plane_areas[ta], '--> ',ta


 ### Find Thickness
 fa=plane_areas[topareas[0]]
 fa1=fa[0]
 if len(fa)>1:
    fa2=fa[1]
 else:
    fa2=plane_areas[topareas[1]][0]


 POSSIBLE_THK=[2.0,3.0,4.0,5.0,6.0,8.0,10.0,12.0,15.0,20.0,25.0,30.0]
 if is_planes_parallels(faces_tree['Plane'][fa1],faces_tree['Plane'][fa2]):
    thk=round(faces_tree['Plane'][fa1].distToShape(faces_tree['Plane'][fa2])[0],1)
    #print 'thk: ',thk
    if thk in POSSIBLE_THK:
        print 'It could be a plane of ',thk,' mm thick'


 ### find adjacents faces 

 planes= dict(faces_tree['Plane']).items()
 contacts={}
 count_adjacents=0
 count_planes=len(planes)
 for index_plane in range(0,count_planes):
    linked=[]
    p=planes[index_plane]
    ee=p[1].Wires[0].Edges
    for index_compare in range(0,count_planes):
        cp=planes[index_compare]
        ei=cp[1].Wires[0].Edges
        if index_plane!=index_compare:
            adjacent=[]
            for geo1 in range(0,len(ee)):
                for geo2 in range(0,len(ei)):
                    if ee[geo1].isSame(ei[geo2]):
                        count_adjacents+=1
                        adjacent.append([geo1,index_compare,geo2])
                        #print 'faces:',index_plane,".",geo1," - ",index_compare,".",geo2
                        linked.append(adjacent)
    contacts[index_plane]=linked

            
 print len(contacts),' linked faces found:' 
 pp.pprint(contacts)



 ### to be done............	
 c_list=[]
 for i in c_surf: 
	c_list.append(i)

 while len(c_list)>1:
    blend=c_list.pop()
    not_found=True
    ind=0
    while ind<len(c_list) and not_found:
       c1=faces[blend]
       c2=faces[c_list[ind]]
       thickness=c1.Surface.Radius-c2.Surface.Radius

       cc1=c1.Surface.Center
       cc2=c2.Surface.Center 
       equal_center=(round(cc1.x, 2)==round(cc2.x, 2)) and (round(cc1.y, 2)==round(cc2.y, 2)) and (round(cc1.z, 2)==round(cc2.z, 2))
       if (equal_center) and (thickness!=0):
       	  print 'Face',blend,' with Face',c_list[ind],' thickness:',thickness

          dcol[c_list[ind]]=(1.,0.,1.)
          dcol[blend]=(1.,0.,1.)

          # save in blend part
          b_part.append(dict(radius1=blend,radius2=c_list[ind]))
          not_found=False
          del c_list[ind]

          # find faces adjacent
          #edges=blend["face"].Edges
          #for e in edges:
          #  print('edges: ',e.Curve.__class__.__name__)
          #  if e.Curve.__class__.__name__=='GeomLineSegment':
          #     e_link=e
          #     for psi in p_surf:             
          #         for pse in psi["face"].Edges:
          #             if pse==e_link:
		  #			   print('Found linked Surface')     

       ind=ind+1

 sel.Object.ViewObject.DiffuseColor=dcol
 print b_part
 return


print "Let's begin..."
pp = pprint.PrettyPrinter(indent=4)

sels=Gui.Selection.getSelectionEx()

count=0
for sel in sels:
    obj=sel.Object
    if hasattr(obj,"Shape"):
        print "Object ", obj.Label
        count+=1
        deconstruct_object(obj)
print 'Rilevati nr ',count,' oggetti'