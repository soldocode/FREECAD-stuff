########################################################################
#                                                                      #
#  Riccardo Soldini - riccardo.soldini@gmail.com                       #
#                                                                      #
#  reversE.py - 2017                                                   #
#                                                                      #
#  Modulo per la decostruzione di parti di carpenteria da file STEP    #
#  ricostruzione in parti in formato makEasy                           #
#  e generazione del processo di costruzione  (workflow)               #
#                                                                      #
########################################################################

from FreeCAD import Vector,Placement,Rotation
import pprint
import math
import g2
fac=[]

POSSIBLE_THK=[2.0,2.5,3.0,4.0,5.0,6.0,8.0,10.0,12.0,15.0,20.0,25.0,30.0,35.0,40.0]
POSSIBLE_UNP=[40,50,60,65,80,100,120,140,160,180,180,200,220,240,300]
POSSIBLE_HEA={220:[220,210]}
COMMON_COMP={'RIDUZIONE_CONCENTRICA_114_76':{'name':'Riduzione concentrica D114-76'},
             'ROSETTA_DIN7980_d_10':{'name':'Rosetta piana d10'},
             'VITE_UNI5739_M10x30':{'name':'Vite TE M10x30'},
             '3572_BB14_00':{'name':'Profilo a U 28x14 L=200'},
             'p9.1.1.1.1.1.1':{'name':'Piastrina fissatubo'},
             'S400-1102D':{'name':'Piastrina fissatubo'},
             'supporto.1.1.1.1':{'name':'Supporto ripari L=20'},
             'supporto.1.2.1.1':{'name':'Supporto ripari L=40'},
             'S300-1191A_00.1':{'name':'Piastrina supporto ripari L=40'},
             'S300-1191A_00.2':{'name':'Piastrina supporto ripari L=20'},
             'S300-1126B':{'name':'Blocchetti 30x20x10 filettati'}}
PARTS={}

def normalized_degrees(angle):
     accuracy=7
     a=math.degrees(round(angle,accuracy))
     n=a-int(a/360)*360
     if n<0:n=n+360
     return n


def angle_between_planes(face1,face2):
    vns1 = face1.normalAt(0,0)
    vns2 = face2.normalAt(0,0)
    alpha = math.degrees( vns1.getAngle( vns2 ) )
    print ('angle between faces:',alpha)
    return alpha

def angle_to_Z(face):
    vns1 = FreeCAD.Vector(0,0,1)
    vns2 = face.normalAt(0,0)
    alpha = math.degrees( vns1.getAngle( vns2 ) )
    print ('angle to Z plane:',alpha)
    return alpha

def angle_to_Y(face):
    vns1 = FreeCAD.Vector(0,1,0)
    vns2 = face.normalAt(0,0)
    alpha = math.degrees( vns1.getAngle( vns2 ) )
    print ('angle to Y plane:',alpha)
    return alpha

def angle_to_X(face):
    vns1 = FreeCAD.Vector(1,0,0)
    vns2 = face.normalAt(0,0)
    alpha = math.degrees( vns1.getAngle( vns2 ) )
    print ('angle to X plane:',alpha)
    return alpha

def is_edges_parallels(edge1,edge2):
    result=False
    d1=edge1.Curve.Direction
    d2=edge2.Curve.Direction
    print (d1)
    print (d2)
    if abs(d1.x)==abs(d2.x) and abs(d1.y)==abs(d2.y) and abs(d1.z)==abs(d2.z):
        print ('paralleli')
        result=True
    return result

def get_parallel_edges(face):

    e_list=[]
    for i in range(0,len(face.OuterWire.Edges)):
        found=False
        e=face.OuterWire.Edges[i]
        for c in e_list:
           if is_edges_parallels(e,face.OuterWire.Edges[c[0]]):
               c.append(i)
               found=True
        if not found:
            e_list.append([i])

    dist={}
    for pe in e_list:
        if len(pe)>1:
            e1=face.OuterWire.Edges[pe.pop(0)]
            p1=g2.Point(e1.Vertexes[0].X,e1.Vertexes[0].Y)
            p2=g2.Point(e1.Vertexes[1].X,e1.Vertexes[1].Y)
            l1=g2.Line(p1,p2)
            for e in pe:
                e2=face.OuterWire.Edges[e]
                p1=g2.Point(e2.Vertexes[0].X,e2.Vertexes[0].Y)
                p2=g2.Point(e2.Vertexes[1].X,e2.Vertexes[1].Y)
                l2=g2.Line(p1,p2)
                print(l1)
                print(l2)
                
    return dist

def is_planes_parallels(face1,face2):

    def plane_from_3points(p1,p2,p3):

       M=[float(p2.X-p1.X),float(p2.Y-p1.Y),float(p2.Z-p1.Z),
          float(p3.X-p1.X),float(p3.Y-p1.Y),float(p3.Z-p1.Z)]
       K=[M[1]*M[5]-M[2]*M[4],
          M[2]*M[3]-M[0]*M[5],
          M[0]*M[4]-M[1]*M[3]]
       P=[K[0],K[1],K[2],-(K[0]*p1.X+K[1]*p1.Y+K[2]*p1.Z)]
       return P

    result=False
    v1=face1.OuterWire.Vertexes
    p1=plane_from_3points(v1[0],v1[1],v1[2])

    v2=face2.OuterWire.Vertexes
    p2=plane_from_3points(v2[0],v2[1],v2[2])

    n=p1[0]*p2[0]+p1[1]*p2[1]+p1[2]*p2[2]
    sq1=math.sqrt(p1[0]**2+p1[1]**2+p1[2]**2)
    sq2=math.sqrt(p2[0]**2+p2[1]**2+p2[2]**2)
    if sq1*sq2!=0.0:
        cosP=n/(sq1*sq2)
    else:
        cosP=0
    #print 'cosP:',cosP
    if abs(cosP)==1: result=True
  
    return result



def find_adjacent(faces,first):
    group=[first]
    contacts={}
    count_adjacents=0
    while len(group)>0:
        #print 'group:', group
        index_face=group.pop(0)
        if not index_face in contacts:
            contacts[index_face]={}      
            e1=faces[index_face].OuterWire.Edges
            for index_compare in range(0,len(faces)):
                if index_compare!=index_face:
                    e2=faces[index_compare].OuterWire.Edges
                    for geo1 in range(0,len(e1)):
                        for geo2 in range(0,len(e2)):
                            if e1[geo1].isSame(e2[geo2]):
                                count_adjacents+=1
                                contacts[index_face][geo1]=[index_compare,geo2]
                                if index_compare not in group:group.append(index_compare)
 
    print (len(contacts),' linked faces found:') 
    pp.pprint(contacts)
    return contacts


def min_faces_distance(faces,planes):
    dist=1000.0
    while len(faces)>0:
        f=faces.pop()
        for i in faces:
            d=round(planes[f].distToShape(planes[i])[0],1)
            if d<dist:dist=d
    return dist


def max_faces_distance(faces,planes):
    dist=0
    while len(faces)>0:
        f=faces.pop()
        for i in faces:
            d=round(planes[f].distToShape(planes[i])[0],1)
            if d>dist:dist=d
    return dist


def max_found_len(faces,planes):
    l=0
    for f in faces:
        for e in planes[f].Edges:
         if e.Length>l:
             l=e.Length
    return round(l,0)

def min_found_len(faces,planes):
    l=1000000
    for f in faces:
        for e in planes[f].Edges:
         if e.Length<l:
             l=e.Length
    return round(l,2)


def deconstruct_object(obj):

 def build_areas_dict(faces):
    faces_areas={}
    for i in range(0,len(faces)):
       area=faces[i].Area
       if area in faces_areas:
               faces_areas[area].append(i)
       else:
               faces_areas[area]=[i]
    return faces_areas 

 def build_tree(faces):
     faces_tree={"Plane":{},
              "Cylinder":{},
              "Cone":{}}

      ### Build faces's tree
     for i in range(0,len(faces)):
       str_face=faces[i].Surface.__str__()
       if str_face=="<Cylinder object>":
           #print ("Cylinder",i," - center:",faces[i].Surface.Center)
           c_surf[i]=faces[i]
           faces_tree['Cylinder'][i]=faces[i]
       elif str_face=="<Plane object>":
           #print ("Plane",i," - number of edges:",len(faces[i].Edges))
           p_surf[i]=faces[i]	
           faces_tree['Plane'][i]=faces[i]     
       elif str_face=="<Cone object>":
           #print ("Cone",i," - center",faces[i].Surface.Center)
           faces_tree['Cone'][i]=faces[i]

     return faces_tree

 part_name='indefinito'
 comcomp=False
 for c in COMMON_COMP:
     if c in obj.Label:
       part_name=COMMON_COMP[c]['name']
       comcomp=True
 if not comcomp:
  faces=obj.Shape.Faces

  c_surf={}
  p_surf={}
  b_part=[]
  
  fnum=len(faces)
  print ('Number of faces:',fnum)

  ### create color tree
  actcolor=sel.Object.ViewObject.DiffuseColor[0]
  dcol=[]
  for i in range (0,fnum):
     dcol.append(actcolor)

  faces_areas=build_areas_dict(faces)
  faces_tree=build_tree(faces)

  ### Find greater faces
  eight_top_areas=sorted(faces_areas,reverse=True)[:8]
  #print (eight_top_areas)
  eight_bigger_faces=[]
  count=0
  index=0
  while (count<8) and (index<len(eight_top_areas)):
     #print 'f:',faces_areas[eight_top_areas[index]]
     for i in range (0,len(faces_areas[eight_top_areas[index]])):
         eight_bigger_faces.append(faces_areas[eight_top_areas[index]][i])
         count+=1
     index+=1
  print ('ebf:',eight_bigger_faces)
  classified=False

  ##### is it round tube? #####
  curved_faces=True
  group=list(eight_bigger_faces)
  for i in range(0,4):
      if group[i] not in faces_tree['Cylinder']:
          curved_faces=False
  
  if curved_faces:
      dd=[]
      for n in range (0,4):
          nn=eight_bigger_faces[n]
          for m in range (0,4):
              mm=eight_bigger_faces[m]
              dist=round(faces_tree['Cylinder'][mm].distToShape(faces_tree['Cylinder'][nn])[0],2)
              if dist not in dd: dd.append(dist)
      if len(dd)==2:
          dd.remove(0)
          diam=0
          lenght=0
          for i in range (0,4):
              ff=faces_tree['Cylinder'][eight_bigger_faces[i]]
              d=ff.Surface.Radius*2
              if d>diam:diam=d
              edges=ff.OuterWire.Edges
              for e in edges:
                  if str(e.Curve.__class__)=="<type 'Part.GeomLineSegment'>":
                      if e.Length>lenght:lenght=e.Length
          
          part_name= "Tubo tondo diam."+str(diam)+"x"+str(dd[0])+" L="+str(lenght)
          classified=True

  
  if not classified:
     six_faces=[]
     four_faces=[]
     two_faces=[]
     pface_count=0
     group=[]
     #print faces_tree['Plane'].keys()
     #print eight_bigger_faces
     for g in list(eight_bigger_faces):
        if g in faces_tree['Plane'].keys():
          pface_count+=1
          group.append(g)
     #print 'gr',group
     while len(group)>0:
         sample=group.pop(0)
         #print sample
         matched=[]
         matched_count=1
         for i in group:
             #print i
             if is_planes_parallels(faces_tree['Plane'][sample],faces_tree['Plane'][i]):
                 matched_count+=1
                 matched.append(i)
         matched.append(sample)
         print  ('mached_count:',matched_count)   
         if matched_count==6:
             six_faces.append(matched)
         if matched_count==4:
             #print ("4 parallels faces found:",matched)
             four_faces.append(matched)
         if matched_count==2:
             #print ("2 parallels faces found:",matched)
             two_faces.append(matched)

     print ('six faces macthed:',len(six_faces))
     print ('four faces macthed:',len(four_faces))
     print ('two faces macthed:',len(two_faces))
     ##### is it a H or I profile? #####
     if len(four_faces)==1 and len(two_faces)==2:
         f1=faces_tree['Plane'][four_faces[0][0]]
         za=angle_to_X(f1)
         pos = obj.Placement.Base
         rot = Rotation(Vector(1,0,0),-za)
         newplace = Placement(pos,rot,Vector(0,0,0))
         obj.Placement = newplace
         faces=obj.Shape.Faces
         faces_tree=build_tree(faces)
         f1=faces_tree['Plane'][four_faces[0][0]]
         za=angle_to_Y(f1)
         pos = obj.Placement.Base
         rot = Rotation(Vector(0,1,0),-za)
         newplace = Placement(pos,rot,Vector(0,0,0))
         obj.Placement = newplace
         faces=obj.Shape.Faces
         faces_tree=build_tree(faces)
         size1=int(max_faces_distance(list(four_faces[0]),faces_tree['Plane']))
         f1=faces_tree['Plane'][four_faces[0][0]]
         for e in f1.Edges:
             for v in e.Vertexes:
                 print (v.Z)
         #pe=get_parallel_edges(faces_tree['Plane'][four_faces[0][0]])
         #print ('angletoZ:',za)
         za=angle_to_Z(f1)
         #dd=get_distances_in_parallel_edges(pe)
         #size2=int(max_faces_distance(list(four_faces[1]),faces_tree['Plane']))
         # find
         print (size1)
         print (min_faces_distance(list(four_faces[0]),faces_tree['Plane']))
         part_name='I o H profile'
         classified=True

     ##### is it a rect/square tube? #####
     if len(four_faces)==2:
         classified=True
         size1=int(max_faces_distance(list(four_faces[0]),faces_tree['Plane']))
         size2=int(max_faces_distance(list(four_faces[1]),faces_tree['Plane']))
         thk=min_faces_distance(list(four_faces[0]),faces_tree['Plane'])
         lenght=max_found_len(list(four_faces[0]),faces_tree['Plane'])
         if size1==size2:
             part_name= "Tubo quadro "+str(size1)+"x"+str(thk)+" L="+str(lenght)
         elif size1>size2:
             part_name= "Tubo rettangolare "+str(size1)+"x"+str(size2)+"x"+str(thk)+" L="+str(lenght)
         else:
             part_name= "Tubo rettangolare "+str(size2)+"x"+str(size1)+"x"+str(thk)+" L="+str(lenght)
     ##### is it a UNP profile? #####
     elif len(two_faces)==2:
         size1=int(max_faces_distance(list(two_faces[0]),faces_tree['Plane']))
         size2=int(max_faces_distance(list(two_faces[1]),faces_tree['Plane']))
         lenght=max_found_len(list(two_faces[0]),faces_tree['Plane'])
         #print size1
         if size1>size2 and size1 in POSSIBLE_UNP:
             classifed=True
             part_name= "UNP "+str(size1)+" L="+str(lenght)
         elif size2 in POSSIBLE_UNP:
             classifed=True
             part_name= "UNP "+str(size2)+" L="+str(lenght)

  
  ### find thickness
  if not classified:
   same_geometry=False
   group=list(eight_bigger_faces)
   
   if (group[0] in faces_tree['Plane']) and (group[1] in faces_tree['Plane']):
     f1=faces_tree['Plane'][group[0]]
     f2=faces_tree['Plane'][group[1]]
     same_geometry=True
   if (group[0] in faces_tree['Cylinder']) and (group[1] in faces_tree['Cylinder']):
     f1=faces_tree['Cylinder'][group[0]]
     f2=faces_tree['Cylinder'][group[1]]
     same_geometry=True 
 
   if same_geometry:
    thk=round(f1.distToShape(f2)[0],1)
    print ('thk: ',thk)

    if thk in POSSIBLE_THK:
          part_name= 'Sagoma sp. '+str(thk)+' mm'

    weight=round(obj.Shape.Volume*0.0000079,1)
    part_name+=' ('+str(weight)+'kg)'
      
    c_surf=list(faces_tree['Cylinder'])
    nblend=0
    blend_faces=[]
    #print c_surf
    while len(c_surf)>0:
      s1=c_surf.pop(0)
      not_found=True
      ind=0
      while ind<len(c_surf) and not_found:
          c1=faces_tree['Cylinder'][s1]
          c2=faces_tree['Cylinder'][c_surf[ind]]
          blend_thk=c1.Surface.Radius-c2.Surface.Radius
          #print 'bt ',blend_thk
          cc1=c1.Surface.Center
          cc2=c2.Surface.Center 
          eqX=round(cc1.x, 2)==round(cc2.x, 2)
          eqY=round(cc1.y, 2)==round(cc2.y, 2)
          eqZ=round(cc1.z, 2)==round(cc2.z, 2)
          equal_center= (eqX and eqY) or (eqX and eqZ) or (eqZ and eqY)
          if (equal_center) and (abs(blend_thk)==thk):
             nblend+=1
             not_found=False
             print ('blend faces...: ',s1,' and ',c_surf[ind])
             blend_faces.append(s1)
             blend_faces.append(c_surf[ind])
          ind+=1
    if nblend==1: part_name+=" con nr "+str(nblend)+" piega"
    if nblend>1: part_name+=" con nr "+str(nblend)+" pieghe"
    if nblend>0:
        #print 'find adjacent...maybe..',eight_bigger_faces
        contacts=find_adjacent(faces,eight_bigger_faces[0])
        adc=contacts[eight_bigger_faces[0]]
        print ('adc:',adc)
        if eight_bigger_faces[0] in faces_tree['Plane']:
            for b in blend_faces:
                for ad in adc:
                    if b==adc[ad][0]:
                        print (' Trovato!!!' ,adc[ad])
                        f1=faces[eight_bigger_faces[0]]
                        f2=faces[adc[ad][0]]
                        e1= f1.OuterWire.Edges[ad]
                        e2= f2.OuterWire.Edges[adc[ad][1]]
                        fac.append(e1)
                        fac.append(e2)
                        #fp=e1.Curve.StartPoint
                        #ep=e1.Curve.EndPoint
                        fp=e1.Vertexes[0]
                        ep=e1.Vertexes[1]
                        dx=round(fp.X-ep.X,3)
                        dy=round(fp.Y-ep.Y,3)
                        dz=round(fp.Z-ep.Z,3)
                        a=angle_between_planes(f1,f2)
                        print (angle_to_Z(f1))
                        print ('deltas:',dx,'|',dy,'|',dz,'->',a)
        #fac.append(faces[eight_bigger_faces[0]])
    
 ### find adjacents faces 
 #find_adjacent(planes)

 if part_name in PARTS:
     PARTS[part_name]['count']+=1
     PARTS[part_name]['objects'].append(obj.Label)
 else:
     PARTS[part_name]={'count':1,'objects':[obj.Label]}
 return


print ("Let's begin...")
pp = pprint.PrettyPrinter(indent=4)

sels=Gui.Selection.getSelectionEx()

count=0
for sel in sels:
    obj=sel.Object
    if hasattr(obj,"Shape"):
        if obj.Shape.Volume>0:
            #print "Object ", obj.Label
            count+=1
            deconstruct_object(obj)
print ('Rilevati nr ',count,' oggetti')
pp.pprint(PARTS)

for item in PARTS:
    print (item+'  |  '+str(PARTS[item]['count']))