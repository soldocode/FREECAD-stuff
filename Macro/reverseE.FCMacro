########################################################################
#                                                                      #
#  Riccardo Soldini - riccardo.soldini@gmail.com                       #
#                                                                      #
#  reversE.py - 2017                                                   #
#                                                                      #
#  Modulo per la decostruzione di parti di carpenteria da file STEP    #
#  ricostruzione in parti in formato makEasy                           #
#  e generazione del processo di costruzione  (workflow)               #
#                                                                      #
########################################################################

from FreeCAD import Vector,Placement,Rotation
import pprint
import math
import g2
from MeFunctions import *
VARS=[]

POSSIBLE_THK=[2.0,2.5,3.0,4.0,5.0,6.0,8.0,10.0,12.0,15.0,20.0,25.0,30.0,35.0,40.0]
POSSIBLE_UNP=[40,50,60,65,80,100,120,140,160,180,180,200,220,240,300]
POSSIBLE_HEA={220:[220,210]}
COMMON_COMP={'RIDUZIONE_CONCENTRICA_114_76':{'name':'Riduzione concentrica D114-76'},
             'ROSETTA_DIN7980_d_10':{'name':'Rosetta piana d10'},
             'VITE_UNI5739_M10x30':{'name':'Vite TE M10x30'},
             '3572_BB14_00':{'name':'Profilo a U 28x14 L=200'},
             'p9.1.1.1.1.1.1':{'name':'Piastrina fissatubo'},
             'S400-1102D':{'name':'Piastrina fissatubo'},
             'supporto.1.1.1.1':{'name':'Supporto ripari L=20'},
             'supporto.1.2.1.1':{'name':'Supporto ripari L=40'},
             'S300-1191A_00.1':{'name':'Piastrina supporto ripari L=40'},
             'S300-1191A_00.2':{'name':'Piastrina supporto ripari L=20'},
             'S300-1126B':{'name':'Blocchetti 30x20x10 filettati'}}
PARTS={}
DWG={'SHEETS':{'THK':{}},'PROFILE':{},'COMPONENTS':{}}


def is_in_POSSIBLE_HEA(obj):
    keys=list(POSSIBLE_HEA.keys())
    result=[False]
    found=False
    bb=get_box_dimensions(obj)
    ax=['X','Y','Z']
    while len(keys)>0 and not found:
        k=keys.pop()
        c=POSSIBLE_HEA[k]
        for i in range(0,3):
            a=ax.pop(0)
            ax.append(a)
            b=bb.pop(0)
            bb.append(b)
            for i in range (0,2):
                a=ax.pop(1)
                ax.append(a)
                b=bb.pop(1)
                bb.append(b)
                if round(bb[0],4)==c[0] and round(bb[1],4)==c[1]:
                    found=True
                    result=[True,list(bb)]
                    print (result)
                    print (ax)           
    return result 


def deconstruct_object(obj):

 def build_areas_dict(faces):
    faces_areas={}
    for i in range(0,len(faces)):
       area=faces[i].Area
       if area in faces_areas:
               faces_areas[area].append(i)
       else:
               faces_areas[area]=[i]
    return faces_areas 

 def build_tree(faces):
     faces_tree={"Plane":{},
              "Cylinder":{},
              "Cone":{}}

      ### Build faces's tree
     for i in range(0,len(faces)):
       str_face=faces[i].Surface.__str__()
       if str_face=="<Cylinder object>":
           #print ("Cylinder",i," - center:",faces[i].Surface.Center)
           c_surf[i]=faces[i]
           faces_tree['Cylinder'][i]=faces[i]
       elif str_face=="<Plane object>":
           #print ("Plane",i," - number of edges:",len(faces[i].Edges))
           p_surf[i]=faces[i]	
           faces_tree['Plane'][i]=faces[i]     
       elif str_face=="<Cone object>":
           #print ("Cone",i," - center",faces[i].Surface.Center)
           faces_tree['Cone'][i]=faces[i]

     return faces_tree


 def get_any_blends(c_surf):
    #c_surf=list(faces_tree['Cylinder'])
    nblend=0
    blend_faces=[]
    print (c_surf)
    while len(c_surf)>0:
      s1=c_surf.pop(0)
      not_found=True
      ind=0
      while ind<len(c_surf) and not_found:
          c1=faces_tree['Cylinder'][s1]
          c2=faces_tree['Cylinder'][c_surf[ind]]
          blend_thk=round(c1.Surface.Radius-c2.Surface.Radius,2)
          print ('bt ',blend_thk)
          cc1=c1.Surface.Center
          cc2=c2.Surface.Center 
          print('cc1:',cc1)
          print('cc2:',cc2)
          eqX=round(cc1.x, 2)==round(cc2.x, 2)
          eqY=round(cc1.y, 2)==round(cc2.y, 2)
          eqZ=round(cc1.z, 2)==round(cc2.z, 2)
          equal_center= (eqX and eqY) and (eqX and eqZ) and (eqZ and eqY)
          if (equal_center) and (abs(blend_thk)==thk):
             nblend+=1
             not_found=False
             print ('blend faces...: ',s1,' and ',c_surf[ind])
             blend_faces.append(s1)
             blend_faces.append(c_surf[ind])
          ind+=1
          VARS.append(c1)
          #print(nblend)
    return blend_faces


 weight=round(obj.Shape.Volume*0.0000079,1)
 part_name='indefinito'
 classified=False
 for c in COMMON_COMP:
     if c in obj.Label:
       part_name=COMMON_COMP[c]['name']
       classified=True
 if not classified:
  faces=obj.Shape.Faces

  c_surf={}
  p_surf={}
  b_part=[]
  
  fnum=len(faces)
  print ('Number of faces:',fnum)

  ### create color tree
  actcolor=sel.Object.ViewObject.DiffuseColor[0]
  dcol=[]
  for i in range (0,fnum):
     dcol.append(actcolor)

  faces_areas=build_areas_dict(faces)
  faces_tree=build_tree(faces)

  ### Find greater faces
  eight_top_areas=sorted(faces_areas,reverse=True)[:8]
  #print (eight_top_areas)
  eight_bigger_faces=[]
  count=0
  index=0
  while (count<8) and (index<len(eight_top_areas)):
     #print 'f:',faces_areas[eight_top_areas[index]]
     for i in range (0,len(faces_areas[eight_top_areas[index]])):
         eight_bigger_faces.append(faces_areas[eight_top_areas[index]][i])
         count+=1
     index+=1
  print ('ebf:',eight_bigger_faces)
  classified=False

  ##### is it round tube? #####
  curved_faces=True
  group=list(eight_bigger_faces)
  for i in range(0,4):
      if group[i] not in faces_tree['Cylinder']:
          curved_faces=False
  
  if curved_faces:
      dd=[]
      for n in range (0,4):
          nn=eight_bigger_faces[n]
          for m in range (0,4):
              mm=eight_bigger_faces[m]
              dist=round(faces_tree['Cylinder'][mm].distToShape(faces_tree['Cylinder'][nn])[0],2)
              if dist not in dd: dd.append(dist)
      if len(dd)==2:
          dd.remove(0)
          diam=0
          lenght=0
          for i in range (0,4):
              ff=faces_tree['Cylinder'][eight_bigger_faces[i]]
              d=ff.Surface.Radius*2
              if d>diam:diam=d
              edges=ff.OuterWire.Edges
              for e in edges:
                  if str(e.Curve.__class__)=="<type 'Part.GeomLineSegment'>":
                      if e.Length>lenght:lenght=e.Length
          
          part_name= "Tubo tondo diam."+str(diam)+"x"+str(dd[0])+" L="+str(lenght)
          classified=True

  
  if not classified:
     six_faces=[]
     four_faces=[]
     two_faces=[]
     pface_count=0
     group=[]
     #print faces_tree['Plane'].keys()
     #print eight_bigger_faces
     for g in list(eight_bigger_faces):
        if g in faces_tree['Plane'].keys():
          pface_count+=1
          group.append(g)
     #print 'gr',group
     while len(group)>0:
         sample=group.pop(0)
         #print sample
         matched=[]
         matched_count=1
         for i in group:
             #print i
             if is_planes_parallels(faces_tree['Plane'][sample],faces_tree['Plane'][i]):
                 matched_count+=1
                 matched.append(i)
         matched.append(sample)
         print  ('mached_count:',matched_count)   
         if matched_count==6:
             six_faces.append(matched)
         if matched_count==4:
             #print ("4 parallels faces found:",matched)
             four_faces.append(matched)
         if matched_count==2:
             #print ("2 parallels faces found:",matched)
             two_faces.append(matched)

     #print ('six faces macthed:',len(six_faces))
     #print ('four faces macthed:',len(four_faces))
     #print ('two faces macthed:',len(two_faces))
     ##### is it a H or I profile? #####
     if len(four_faces)==1 and len(two_faces)==2:
         f1=faces_tree['Plane'][four_faces[0][0]]
         za=angle_to_X(f1)
         pos = obj.Placement.Base
         rot = Rotation(Vector(1,0,0),-za)
         newplace = Placement(pos,rot,Vector(0,0,0))
         obj.Placement = newplace
         faces=obj.Shape.Faces
         faces_tree=build_tree(faces)
         f1=faces_tree['Plane'][four_faces[0][0]]
         za=angle_to_Y(f1)
         pos = obj.Placement.Base
         rot = Rotation(Vector(0,1,0),-za)
         newplace = Placement(pos,rot,Vector(0,0,0))
         obj.Placement = newplace
         faces=obj.Shape.Faces
         faces_tree=build_tree(faces)
         f1=faces_tree['Plane'][four_faces[0][0]]
         hea=is_in_POSSIBLE_HEA(obj)
         print (hea)
         if hea[0]==True:
             print (hea[1])
             part_name='HEA '+str(hea[1][0])+' L='+str(round(hea[1][2]))+' ('+str(weight)+')'
             classified=True

     ##### is it a rect/square tube? #####
     if not classified and len(four_faces)==2:
         classified=True
         size1=int(max_faces_distance(list(four_faces[0]),faces_tree['Plane']))
         size2=int(max_faces_distance(list(four_faces[1]),faces_tree['Plane']))
         thk=min_faces_distance(list(four_faces[0]),faces_tree['Plane'])
         lenght=max_found_len(list(four_faces[0]),faces_tree['Plane'])
         if size1==size2:
             part_name= "Tubo quadro "+str(size1)+"x"+str(thk)+" L="+str(lenght)
         elif size1>size2:
             part_name= "Tubo rettangolare "+str(size1)+"x"+str(size2)+"x"+str(thk)+" L="+str(lenght)
         else:
             part_name= "Tubo rettangolare "+str(size2)+"x"+str(size1)+"x"+str(thk)+" L="+str(lenght)
     ##### is it a UNP profile? #####
     elif len(two_faces)==2:
         size1=int(max_faces_distance(list(two_faces[0]),faces_tree['Plane']))
         size2=int(max_faces_distance(list(two_faces[1]),faces_tree['Plane']))
         lenght=max_found_len(list(two_faces[0]),faces_tree['Plane'])
         #print size1
         if size1>size2 and size1 in POSSIBLE_UNP:
             classifed=True
             part_name= "UNP "+str(size1)+" L="+str(lenght)
         elif size2 in POSSIBLE_UNP:
             classifed=True
             part_name= "UNP "+str(size2)+" L="+str(lenght)

  
  ### find thickness
  if not classified:
   same_geometry=False
   group=list(eight_bigger_faces)
   
   if (group[0] in faces_tree['Plane']) and (group[1] in faces_tree['Plane']):
     f1=faces_tree['Plane'][group[0]]
     f2=faces_tree['Plane'][group[1]]
     same_geometry=True
   if (group[0] in faces_tree['Cylinder']) and (group[1] in faces_tree['Cylinder']):
     f1=faces_tree['Cylinder'][group[0]]
     f2=faces_tree['Cylinder'][group[1]]
     same_geometry=True 
 
   if same_geometry:
    thk=round(f1.distToShape(f2)[0],1)
    print ('thk: ',thk)

    if thk in POSSIBLE_THK:
          part_name= 'Sagoma sp. '+str(thk)+' mm'

    weight=round(obj.Shape.Volume*0.0000079,1)
    part_name+=' ('+str(weight)+'kg)'

    
    blend_faces=get_any_blends(list(faces_tree['Cylinder']))     
    nblend=len(blend_faces)/2
    if nblend==1: part_name+=" con nr "+str(nblend)+" piega"
    if nblend>1: part_name+=" con nr "+str(nblend)+" pieghe"


    if nblend>0:
        #print 'find adjacent...maybe..',eight_bigger_faces
        contacts=find_adjacent(faces,eight_bigger_faces[0])
        adc=contacts[eight_bigger_faces[0]]
        print ('adc:',adc)
        if eight_bigger_faces[0] in faces_tree['Plane']:
            for b in blend_faces:
                for ad in adc:
                    if b==adc[ad][0]:
                        print (' Trovato!!!' ,adc[ad])
                        f1=faces[eight_bigger_faces[0]]
                        f2=faces[adc[ad][0]]
                        e1= f1.OuterWire.Edges[ad]
                        e2= f2.OuterWire.Edges[adc[ad][1]]
                        fac.append(e1)
                        fac.append(e2)
                        #fp=e1.Curve.StartPoint
                        #ep=e1.Curve.EndPoint
                        fp=e1.Vertexes[0]
                        ep=e1.Vertexes[1]
                        dx=round(fp.X-ep.X,3)
                        dy=round(fp.Y-ep.Y,3)
                        dz=round(fp.Z-ep.Z,3)
                        a=angle_between_planes(f1,f2)
                        print (angle_to_Z(f1))
                        print ('deltas:',dx,'|',dy,'|',dz,'->',a)
    
 ### find adjacents faces 
 #find_adjacent(planes)

 if part_name in PARTS:
     PARTS[part_name]['count']+=1
     PARTS[part_name]['objects'].append(obj.Label)
 else:
     PARTS[part_name]={'count':1,'objects':[obj.Label]}
 return


print ("Let's begin...")
pp = pprint.PrettyPrinter(indent=4)

sels=Gui.Selection.getSelectionEx()

count=0
for sel in sels:
    obj=sel.Object
    if hasattr(obj,"Shape"):
        if obj.Shape.Volume>0:
            #print "Object ", obj.Label
            count+=1
            deconstruct_object(obj)
print ('Rilevati nr ',count,' oggetti')
pp.pprint(PARTS)

for item in PARTS:
    print (item+'  |  '+str(PARTS[item]['count']))